# Loop

## Introduction

强连通: 有向图中两个顶点存在有向边,可以互相到达

一个循环是CFG中的强连通分量子图

分类: 可规约循环, 不可规约循环 (此处仅简单以入口节点个数进行区分)

单入口可规约循环称为自然循环(Natural Loop)

循环优化的对象主要是自然循环

## Natural Loop

回边(Back edge): CFG中边的目的节点支配源节点, 则称为回边

自然循环: 一条回边h->b, h支配b, 可以形成一个可规约循环; 如果x属于这个循环, 则满足h支配x, 且存在一条路径x->b不经过h。

循环嵌套: 位于外层的循环称为外循环(Outer Loop), 位于内存的循环称为内循环(Inner Loop)

## Loop in LLVM

术语:
1. 循环头节点(Header): 回边的目的节点
2. 闩节点(Latch): 回边的源节点
3. 待退出节(Exiting)点: 跳出循环的节点, 有不再循环内的后继节点

循环外特殊节点:

4. 待进入节点(Entering): 循环头节点循环外的前驱节点
5. 退出节点(Exit): 循环待退出节点循环外的后继节点

如果循环的带进入节点只有一个, 也将该节点称为前置头节点(Preheader)

### 循环识别

逆序遍历CFG对应的支配树, 对于每个支配树节点
1. 识别N构成的回边: 遍历N的(CFG中)前驱, 如果N支配某个前驱, 则两者构成一条回边
2. 如果N有一条及以上条回边, 以N为循环头节点构建循环, 并将所有回边的源节点加入到worklist, 遍历worklist中节点进行判断:
    1. 如果该节点记为M不属于某个循环, 则设定节点M属于节点N的循环。 判断M是否是N, 如果不是则将M的所有前驱加入到worklist; 如果是则不处理(已经到达循环头节点)
    2. 如果M已经属于一个循环L, 则找到L的最外层循环: 如果最外层循环是N的循环, 则不做处理; 如果最外层循环不是N, 则将L作为N的子循环, 将M所有不在L中的前驱节点加入到N的worklist中。

### 循环规范化

循环化简形式(LoopSimplify), 循环旋转形式(LoopRotation), 循环封闭SSA形式(Loop-Closed SSA, LCSSA) 将各种类型的循环转化成统一的循环形式

#### 循环化简形式

循环化简形式特点: 
1. 有循环前置节点(Preheader), 即只有一个循环待进入节点
2. 循环有且仅有一条回边
3. 循环专用的退出节点, 即循环退出节点可以被循环头节点支配, 退出节点的所有前驱都是循环内节点

循环简化形式优势在于方便做一些循环优化: 循环不变量外提, 代码下沉

化简循环形式:
1. 添加循环前置节点
2. 添加专用退出节点
3. 拆分多回边共用循环头节点的循环

#### 循环旋转形式

循环旋转形式是循环的闩节点同时是待退出节点(Exiting), 即为do-while形式

循环旋转形式比旋转化简形式更加规范, 同时也满足循环化简形式。利于Load指令的外提, 循环向量化。

通过旋转循环, 迭代地旋转循环中指令位置, 直到循环变成do-while形式或无法再旋转为止。

为保证语义不变(如循环体一次都没执行), 添加一个判定循环次数的节点称为守卫节点(guard)

#### 循环封闭SSA (LCSSA)

LLVM IR中存在循环, 对循环增加额外约束: 循环中定义的变量只在循环内使用, 如果需要在循环外使用则在循环出口基本块插入Phi函数。满足这样条件的循环称为LCSSA。

虽然添加的phi函数是冗余的节点, 在后续的优化中被删除, 但可以 使循环相关优化更简单: 值范围分析对循环内定义在循环外使用的变量关注, 创建Phi函数后, 就不用分析和关注循环。




