# Intro

LTO: Link-Time Optimization -> 对整个程序代码进行优化，链接时进行跨模块优化

BOLT: inary Optimization and Lay out Tool -> 在配置文件后重新排列可执行文件

# PGO

Profile-Guided Optimization

PGO 首先要对程序进行剖分(Profile)，收集程序实际运行的数据生成 profiling 文件，根据此文件来进行性能优化

缩小代码大小, 减少错误分支预测, 重新组织代码布局减少指令缓存

prof-gen -> generate prof file -> re-compile 

## Cpp 的 PGO 实践

虚函数优化：

1. 虚函数表导致二进制文件变大
2. 虚函数增加了一次内存寻址
3. 间接调用开销：运行期的实际函数(或接口)代码地址是动态赋值的，机器指令无法做更多优化，只能直接执行 call 指令（间接调用）。对于直接调用而言，是不存在分支跳转的，因为跳转地址是编译器确定的，CPU 直接去跳转地址取后面的指令即可，不存在分支预测，这样可以保证 CPU 流水线不被打断。
4. 无法内联优化：virtual 函数的实现本身是多态的，编译中无法得出实际运行期会执行的实现，因此也无法进行内联优化。
5. 阻碍进一步的编译优化：indirect call 相当于是指令中的一个屏障，由于其本身是一个运行期才能确定的调用，它在编译期会使各种控制流判断以及代码展开失效，从而限制进一步编译及链接的优化空间。

